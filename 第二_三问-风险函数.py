import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- 1. 数据准备与合并 ---

# 您的原始数据
# 为了代码简洁，这里仅展示部分数据，但代码会使用完整数组
bmi_data = np.array([
    33.331832, 30.742188, 28.641243, 30.844444, 35.883635, 33.874064, 29.136316, 33.333333, 33.333333, 36.25047,
    30.385016, 35.755956, 35.055632, 30.888889, 30.443839, 28.282828, 28.133657, 28.320313, 35.684444, 28.677663,
    30.043262, 33.284024, 29.752066, 28.040378, 29.136316, 32.046147, 35.058864, 30.385016, 30.483158, 32.561885,
    36.885092, 30.846277, 34.722222, 29.446367, 28.407877, 30.110991, 29.752066, 31.68506, 35.69304, 37.113546,
    30.119376, 30.120482, 29.7442, 28.344671, 28.90625, 33.874064, 32.690542, 34.927679, 38.567493, 39.159843,
    28.90625, 36.132335, 32.051282, 34.289377, 31.229454, 31.732941, 38.946813, 36.289737, 31.640625, 32.046147,
    31.633715, 32.046147, 30.427198, 33.789063, 30.46875, 34.720883, 31.644286, 33.71488, 27.915519, 35.546875,
    34.063609, 29.174885, 31.887755, 30.443839, 32.8125, 29.169333, 32.297866, 28.1476, 32.36855, 30.483158,
    30.486657, 32.522449, 29.12415, 30.661292, 30.483379, 29.752066, 27.202498, 36.923077, 30.043262, 41.132813,
    29.760863, 36.640446, 37.637849, 30.116213, 28.981143, 33.409205, 31.992171, 32.839415, 28.792954, 29.760863,
    40.138408, 32.242064, 30.119402, 34.049031, 30.863036, 33.462225, 35.685352, 30.443839, 37.290688, 30.427198,
    29.899691, 26.619343, 31.25, 29.136316, 35.379813, 31.25, 29.065744, 30.119402, 30.859375, 28.266024,
    32.8125, 29.384757, 29.615806, 28.833793, 30.46875, 29.49495, 29.296875, 39.302112, 30.470522, 29.411765,
    30.078125, 31.288319, 28.344671, 31.75352, 29.136316,
    93.2437362, 110.400254, 116.668369, 102.650094, 103.183044, 103.963022, 95.0016603, 95.415381, 92.6156291,
    97.0200954, 106.028275, 103.075164, 99.6682325, 103.251199, 92.1627171, 105.522922, 98.2973017, 95.0638845,
    101.23238, 105.420952, 94.3469718, 97.9953125, 93.867685, 93.301505, 101.013913, 98.876758, 102.972457,
    110.120956, 93.9075711, 95.8539553, 105.023262, 103.332831, 112.496414, 97.0934702, 96.3381935, 95.2139932,
    101.561435, 108.071684, 98.9923231, 104.289514, 101.090093, 92.483819, 99.3598283, 106.940275, 107.123329,
    102.449745, 101.603933, 95.799683, 88.1709798, 106.453144, 91.5031118, 93.7045037, 106.975997, 92.0742743,
    94.8728431, 93.8317202, 106.904949, 103.550073, 101.429151, 100.366948, 103.090875, 105.74492, 91.5759535,
    99.9182265, 99.9311178, 102.6302, 96.6050429, 99.898312, 98.2269621, 103.833722, 104.155406, 104.956193,
    92.0702004, 102.010799, 104.745771, 99.4175256, 94.9556487
])

predicted_times = np.array([
    100.668648, 98.3450393, 93.6862885, 95.9107209, 111.453665, 107.776385, 91.3624041, 105.196725, 101.293993,
    113.661462, 94.369971, 112.010178, 107.186998, 95.2416782, 98.6940104, 95.3363747, 88.5386008, 91.1535402,
    109.30739, 93.4905442, 96.7259696, 101.486614, 97.7676682, 90.2793576, 93.6062648, 101.029713, 106.279369,
    95.3811131, 98.412584, 102.124561, 114.636413, 100.932574, 108.738427, 96.621701, 88.4480187, 100.894938,
    96.1065093, 98.1898903, 108.389175, 112.353868, 97.8008012, 97.8282944, 96.0304249, 95.7422319, 92.7911029,
    104.390534, 104.547343, 106.724604, 119.253375, 119.582628, 93.5647985, 111.443239, 99.4098514, 104.877116,
    97.282596, 101.133205, 119.930768, 110.60438, 101.701524, 100.259151, 97.5789036, 99.9057308, 95.5809152,
    105.451475, 96.6019781, 106.924252, 98.2832034, 101.854997, 91.6176793, 108.870651, 108.498394, 91.51288,
    101.681329, 97.3665235, 103.104607, 94.8427197, 100.855121, 88.7576428, 101.364449, 96.6266614, 99.5170992,
    102.955182, 95.5911039, 98.2434651, 97.5397026, 96.5724014, 89.1219276, 111.898084, 95.9322522, 127.127094,
    97.0696789, 111.677559, 115.7959, 99.8909647, 96.0591015, 104.014439, 100.031266, 103.058069, 94.4197192,
    96.6075493, 117.498147, 101.250734, 98.9487159, 104.350955, 98.7805711, 106.193691, 112.409905, 95.9438902,
    112.816701, 95.1258732, 88.468084, 88.0123486, 98.6818012, 91.0403455, 110.278957, 100.027221, 96.1508397,
    97.1530639, 98.9738297, 91.611426, 105.313562, 97.4592876, 96.2892631, 96.0740922, 99.1436211, 95.4619736,
    93.8951302, 118.116666, 99.8918478, 96.3254983, 95.1235319, 97.3524704, 93.4531296, 103.061139, 90.8262707,
    92.9219604, 106.882015, 105.576538, 93.2358826, 97.8484546, 95.0468339, 105.33042, 114.024807, 119.162585,
    112.241221, 98.9774588, 101.014246, 105.505117, 103.154432, 93.807247, 95.0053986, 98.0101888, 96.996672,
    100.942181, 107.638163, 103.571802, 94.1691177, 96.3625315, 96.9379715, 99.2542507, 104.658947, 95.1435321,
    103.014793, 96.0287722, 96.3143591, 106.666761, 100.802098, 89.8731728, 105.094329, 99.4435248, 94.7566168,
    93.2437362, 110.400254, 116.668369, 102.650094, 103.183044, 103.963022, 95.0016603, 95.415381, 92.6156291,
    97.0200954, 106.028275, 103.075164, 99.6682325, 103.251199, 92.1627171, 105.522922, 98.2973017, 95.0638845,
    101.23238, 105.420952, 94.3469718, 97.9953125, 93.867685, 93.301505, 101.013913, 98.876758, 102.972457,
    110.120956, 93.9075711, 95.8539553, 105.023262, 103.332831, 112.496414, 97.0934702, 96.3381935, 95.2139932,
    101.561435, 108.071684, 98.9923231, 104.289514, 101.090093, 92.483819, 99.3598283, 106.940275, 107.123329,
    102.449745, 101.603933, 95.799683, 88.1709798, 106.453144, 91.5031118, 93.7045037, 106.975997, 92.0742743,
    94.8728431, 93.8317202, 106.904949, 103.550073, 101.429151, 100.366948, 103.090875, 105.74492, 91.5759535,
    99.9182265, 99.9311178, 102.6302, 96.6050429, 99.898312, 98.2269621, 103.833722, 104.155406, 104.956193,
    92.0702004, 102.010799, 104.745771, 99.4175256, 94.9556487
])

# 确保数据长度一致
min_len = min(len(bmi_data), len(predicted_times))
df = pd.DataFrame({
    'bmi': bmi_data[:min_len],
    'predicted_time': predicted_times[:min_len]
})

# 设置matplotlib以正确显示中文
plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False


# --- 2. 分组与风险函数定义 ---

def assign_bmi_group(bmi):
    """根据您提供的K-Means结果边界，为BMI分配组别"""
    if bmi < 29.95:
        return '低BMI组 (<29.95)'
    elif 29.95 <= bmi < 31.62:
        return '中BMI组 (29.95-31.62)'
    elif 31.62 <= bmi < 33.44:
        return '中高BMI组 (31.62-33.44)'
    else:  # bmi >= 33.44
        return '高BMI组 (>33.44)'


# 将分组信息添加到DataFrame中
df['bmi_group'] = df['bmi'].apply(assign_bmi_group)


def calculate_group_risk(x, group_predicted_times):
    """
    计算单个组在给定检测时间x下的总风险。
    使用新的风险函数: 100*(x-84)/105 * 总人数 + 未达标人数 * 3
    """
    group_size = len(group_predicted_times)
    if group_size == 0:
        return 0

    # 未达标人数：预测时间 > 设定的检测时间x
    not_meeting_standard_count = np.sum(group_predicted_times > x)

    # 总风险 = 100*(x-84)/105 * 总人数 + 未达标人数 * 3
    total_risk = 100 ** ( (x - 84) / 105 ) * group_size + not_meeting_standard_count * 3
    return total_risk


# --- 3. 分析与可视化 ---

def analyze_and_plot_groups(dataframe):
    """对每个组进行风险分析并绘制曲线"""

    plt.figure(figsize=(15, 10))

    # 为每个组定义一个颜色以便区分
    colors = {
        '低BMI组 (<29.95)': 'green',
        '中BMI组 (29.95-31.62)': 'blue',
        '中高BMI组 (31.62-33.44)': 'orange',
        '高BMI组 (>33.44)': 'red'
    }

    # 按顺序获取组名，确保图例顺序一致
    group_names = ['低BMI组 (<29.95)', '中BMI组 (29.95-31.62)', '中高BMI组 (31.62-33.44)', '高BMI组 (>33.44)']

    print("--- 各BMI分组风险分析 (基于新风险函数: 100*(x-84)/105*总人数 + 未达标人数*3) ---")

    for name in group_names:
        group_df = dataframe[dataframe['bmi_group'] == name]
        group_times = group_df['predicted_time'].values
        group_size = len(group_times)

        if group_size == 0:
            print(f"\n组名: {name} - 该组没有样本，已跳过。")
            continue

        # 设定一个覆盖该组所有预测时间的范围进行分析
        time_range = np.linspace(min(group_times) - 5, max(group_times) + 5, 1000)

        # 计算该组在整个时间范围内的风险值
        risks_over_time = [calculate_group_risk(x, group_times) for x in time_range]

        # 找到风险最小的点
        min_risk_value = np.min(risks_over_time)
        # 找到风险值首次达到最小值的那个时刻x
        optimal_x_index = np.argmin(risks_over_time)
        optimal_x = time_range[optimal_x_index]

        # --- 打印该组的结果 ---
        print(f"\n组名: {name}")
        print(f"  - 样本数: {group_size}")
        print(f"  - 预测时间范围: [{np.min(group_times):.2f}, {np.max(group_times):.2f}]")
        print(f"  => 最佳检测时间 (x): {optimal_x:.2f} 天")
        print(f"  => 对应最小风险值: {min_risk_value:.2f}")

        # --- 绘制曲线 ---
        color = colors.get(name)
        plt.plot(time_range, risks_over_time,
                 label=f"{name} (N={group_size})",
                 color=color, linewidth=2.5)

        # 标记最佳点
        plt.scatter(optimal_x, min_risk_value,
                    color=color, s=200, marker='*', zorder=5,
                    edgecolor='black', linewidth=1,
                    label=f'{name} 最佳点')

    plt.title('各BMI分组的队列风险与最佳检测时间\n(风险函数: 100*(x-84)/105*总人数 + 未达标人数*3)', fontsize=16, weight='bold')
    plt.xlabel('设定的检测时间 x (天)', fontsize=14)
    plt.ylabel('队列总风险', fontsize=14)
    plt.legend(fontsize=12, loc='upper right')
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.tight_layout()
    plt.show()


# --- 4. 主程序执行 ---
if __name__ == "__main__":
    analyze_and_plot_groups(df)

    print("\n--- 分析说明 ---")
    print("1. **风险模型**: 本次分析使用新的风险函数 `总风险 = 100**(x-84)/105*总人数 + 未达标人数*3`。")
    print("2. **曲线特征**: 新的风险函数不再是单调的，而是呈现U型曲线。第一部分随着x增加而线性增加，第二部分随着x增加而减少。")
    print("3. **最佳时间**: 图中的星号(*)标出了风险达到最小值的时刻，这是第一部分和第二部分权衡的结果。")